最近把这本书看了一遍，把这本书上写的这45个习惯记录下来，方便自己后续的记忆。

# *做事*</br>
 指责不会修复bug
# *欲速则不达*</br>
  不要坠入快速简单的修复中
# *对事不对人*</br>
    让人骄傲的应该是解决了问题而不应是谁解决了这个问题
# *排除万难，奋勇前进*</br>
    做正确的事情。要有勇气，诚实的说出实情。
# *跟踪变化*</br>
    跟踪技术变化，不需要精通所有技术，但要跟上技术发展的潮流。
# *对团队投资*</br>
    给团队成员提供更好的平台，共同进步。
# *懂得丢弃*  
    学习新的东西，丢弃旧的东西。不要不肯改变，在学习新技术时，不要抱着否定的态度，要积极的接纳。
# *打破沙锅问到底*</br>
    不停的问为什么。不要不懂装懂，对于自己不知道的东西一定要多问为什么，时间来不及也要记下来，下来自己再好好的研究。在问为什么的时候，也要知道自己为什么要一直问为什么。
# *把握开发节奏* 
    在事情变得一团糟之前解决问题。
# *让客户做决定*</br>
    用业务人员能够理解的语言向他们描述需要解决的问题，不要让开发人员自己随意的决定。
# *让设计指导而不是操纵开发*</br>
    任何设计仅仅是一个起跑点，在开发过程中它也在不断的发生变化。好的设计是一张地图，它本身也在不断的进化中。
# *合理地使用技术*</br>
    在选择新的技术框架时，多问问自己几个问题。下面是一些参考:
    * 技术框架是否真的能解决问题?
    * 是否会被绑定到这个框架上?
    * 将来的维护成本你多高。</br>
    在问了自己这些问题之后，再进行决定。必须根据自己的需要来选择技术，不能因为为了用技术而使用技术。对新的技术，多提些问题。
# *保持可以发布*</br>
    对于已经提交的代码，应该保持代码的可用性。为了防止自己提交的代码破坏现有代码，可以按照下面的流程进行设计:
    * 在本地运行测试。首先在本地运行单元测试，对自己编写的代码进行单元测试。
    * 检出最新代码。在对代码提交之前，首先从服务器上下载最新的代码，防止他人提交的代码与自己编写的代码冲突。
    * 提交代码。将通过测试与编译的及时提交至SVN环境。</br>
    对项目需要保持时刻可用性，可以在任意时刻保证项目可以被编译，运行，测试，并可以顺利的完成部署。
# *提早集成、频繁集成*
    虽然独立开发的效率更高，但是系统最终是需要集成在一起协作的。若是在后期再进行统一集成，麻烦会出现很多。在早期进行集成，可以很好的看到各个子系统之间的交互和影响。代码的集成是主要的风险来源，要想规避这个风险，只有提早集成，持续而有规律的开发。
# *提早实现自动化部署*
    关于这一点，深有体会。在单位，之前的工作内容的一部分就是部署版本，从SVN上提取代码，部署到服务器端。由于之前的版本管理不让合作公司部署，这个活就交到了我这个新入职的手上。当时的代码提交单的合并在合作公司有人专门负责，完成合并之后，再从提交单中提取代码，编译、部署，一天感觉全在部署版本，尤其是在业务多或者上线着急的时候。虽然后期写了个python脚步，完成提交单的合并，但是感觉还是有点不成系统。如果在早期就完成了自动化部署的工作，不管测试还是开发，应该都会更加迅速。部署应该有统一的规范，命名、路径应该进行统一的规划。使用部署系统部署应用，在不同的机器上用不同的配置文件测试依赖的问题。
# *使用演示获得频繁反馈*
    在开发应用的时期，要保持应用的可见性，每隔1到2周，邀请客户对系统进行演示，获取客户的反馈。感觉这点现在用起来很费劲，貌似现在的开发都是最终一起交付，中间都没有涉及到客户的评价。之前看到的37signal中，貌似是界面原型很快就给开发出来，最终才去实现后台的交互。在这种情况下，应该会更好的显示出优势吧。
# *使用短迭代，增量发布*
    貌似现在的软件的发布周期都越来越短。firefox感觉就很明显，最开始用的时候，都是小版本号，现在都是大版本，让人感觉进步很多，可能修复的bug和添加的新功能和之前的还是类似，但是感觉很NB的样子。发布 _带有最小功能却可用功能块_ 的产品，在每个增量开发中，使用1-4周左右的迭代周期。
# *固定的价格就意为着背叛承诺*
    软件项目天生就是变化无常的，不可重复。基于真实的工作量评估。
# *守护天使－单元测试*
    之前写的代码实在是太少，在做嵌入式开发时，debug的次数也是近似于无，所有的问题貌似都是printk来查出来的。现在开始写的java代码，终于开始写些单元测试案例，这些东西之前没有用到的确是自己的损失，单元测试案例的使用，可以很好的保证自己代码的正确性，也方便后期问题的排查。好的单元测试能够为你的代码问题提供及时的警报。如果没有到位的单元测试，不要进行任何设计和代码修改。
    * 单元测试能够提供及时反馈
    * 单元测试能使代码更加健壮
    * 单元测试是有用的设计工具；
    * 单元测试是让你自信的后台
    * 单元测试是解决问题时的探测器
    * 单元测试是可信的文档
    * 单元测试是学习工具
# *先用它，再实现它*
    编码之前，先写测试案例。这方面自己做的还很不够，最典型的就是输入输出没有很好的规划，后期需要多学习学习。将TDD作为设计工具。
# *不同的环境，就有不同的问题*
    这个在嵌入式上面应该很常见，不同的内核版本，不同的ARM处理器，能正常跑起来就不正常了。之前用python写的一个小脚本，UTF8的bottom是否存在就导致自己写的脚本在别人的机器上运行存在问题，这方面以后自己还是得多注意。
# *自动验收测试*
    让客户单独验证这些测试，要让它们像一般的案例一样可以自动运行。
# *度量真实进度*
    程序员永远都是乐观的人群，之前在37signal中看到，如果给一个程序员分配3天的时间做一个任务，那么他前两天半都在拖沓，到最后半天才开始编码。不要用不恰当的度量来欺骗自己或者团队，要评估需要完成的待办事项。
# *倾听用户声音*
    每一个抱怨的背后都隐藏了一个事实。找出真相，修复真正的问题。这点应该在大部分场合都适用了。
# *代码要清晰表达意图*
    PIE(Program Intently and Expressively)代码必须明确的说明你的意图，而且必须富有表达力。要编写清晰的代码而不是讨巧的代码。向代码的阅读者表明自己的意图，可读性差的代码一点都不聪明。
# *用代码沟通*
    对于类中的每个方法，在注释中可以包含：目的、需求、承诺、异常这4个方面的内容。用注视进行沟通，使用细心选择、有意义的命名。用注视描述代码的意图和约束，注释不能代替优秀的代码。
# *动态性取舍*
    考虑性能、便利性、生产力、成本和上市时间，如果性能表现足够了，就将注意力放在其他因素上，不要为了感觉上的性能提升或者设计的优雅，而将设计复杂化。
# *增量式编程*
    在很短的编辑/构建/测试循环中编写代码。
# *保持简单*
    keep it simple and stupid.简单不是丑陋。开发出可以工作的、最简单的解决方案。
# *编写内聚的代码*
    让类的功能尽量集中，让组件尽量小。要避免创建很大的类或者组件，也不要创建无所不包的大杂烩。
# *告知，不要询问*
    将命令和查询分开。不要抢别的对象或者组件的工作。只需要告诉它做什么，然后盯着自己的职责就可以了。
# *根据契约进行替换*
    通过替换遵循接口契约的类，进而添加新的功能特性。要多使用委托而不是继承。
# *记录问题解决日志*
    这个现在自己开始做了。遇到问题时，不是简单的搜索解决方案，之后就忘记了。现在开始用wiki把遇到的问题的描述他解决方案给记录下来，方便自己后续的进步。保留解决方案是修复问题过程中的一部分，在以后发现类似问题时，可以有效快速的解决。
# *警告就是错误*
    现在代码的编写中已经开始消除警告。
# *对问题各个击破*
    在解决问题时，要将问题域和周边分开，特别是在大型应用中。
# *报告所有的异常*
    处理或者向上传播异常。不要将异常压制。
# *提供有用的错误信息*
    展示有用的错误信息，提供更易于查找错误的细节。
# *定期安排会面时间*
    使用立会：立会可以让团队达成共识,保证会议短小精悍不跑题.
# *架构师必须写代码*
    优秀的设计从积极的程序员那里开始演化。
# *实行代码集体所有制*
    让开发人员轮换完成系统不同领域中不同模块的任务。不要因为团队中某个人的离职导致没人会。
# *成为指导者*
    分享自己的知识很有趣，付出的同时还有收获。还可以激励别人获得更好的成果，提升整个团队的能力。
# *允许大家自己想办法*
    授之以鱼不如授之以渔。
# *准备好后再共享代码*
    绝不要提交尚未完成的代码。代码只有在单元测试通过之后才可以提交。
# *做代码复查*
    代码审查可以很好的提升代码质量和降低错误率。
# *及时通报进展与问题*
    发布进展情况、新的想法和目前正在关注的主题，不要等别人来问项目状态如何。
